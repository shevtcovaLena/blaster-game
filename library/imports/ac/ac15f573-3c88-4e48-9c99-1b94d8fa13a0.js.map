{"version":3,"sources":["assets\\scripts\\core\\Board.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { Tile } from \"./Tile\";\nimport { TileColor, ALL_COLORS } from \"./TileColor\";\n\n/**\n * Модель игрового поля - двумерная сетка тайлов\n * Отвечает за генерацию, поиск групп, удаление и гравитацию\n */\nexport class Board {\n  private grid: (Tile | null)[][];\n  private tileIdCounter: number = 0;\n\n  constructor(\n    public readonly cols: number,\n    public readonly rows: number,\n  ) {\n    this.grid = [];\n  }\n\n  /**\n   * Генерирует случайное поле, заполняя все ячейки тайлами\n   */\n  generate(): void {\n    for (let x = 0; x < this.cols; x++) {\n      this.grid[x] = [];\n      for (let y = 0; y < this.rows; y++) {\n        this.grid[x][y] = this.createRandomTile(x, y);\n      }\n    }\n  }\n\n  /**\n   * Создаёт тайл случайного цвета\n   */\n  private createRandomTile(x: number, y: number): Tile {\n    const randomColor =\n      ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)];\n    return new Tile(randomColor, x, y, this.tileIdCounter++);\n  }\n\n  /**\n   * Получить тайл по координатам\n   */\n  getTile(x: number, y: number): Tile | null {\n    if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) {\n      return null;\n    }\n    return this.grid[x][y];\n  }\n\n  /**\n   * Установить тайл в ячейку\n   */\n  setTile(x: number, y: number, tile: Tile | null): void {\n    if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {\n      this.grid[x][y] = tile;\n      if (tile) {\n        tile.gridX = x;\n        tile.gridY = y;\n      }\n    }\n  }\n\n  /**\n   * Находит группу связанных тайлов того же цвета (BFS)\n   * @param startX координата X начального тайла\n   * @param startY координата Y начального тайла\n   * @returns массив всех связанных тайлов\n   */\n  findConnectedGroup(startX: number, startY: number): Tile[] {\n    const startTile = this.getTile(startX, startY);\n\n    if (!startTile) {\n      return [];\n    }\n\n    const targetColor = startTile.color;\n    const result: Tile[] = [];\n    const visited: Set<string> = new Set();\n    const queue: Tile[] = [startTile];\n\n    visited.add(`${startX},${startY}`);\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      result.push(current);\n\n      const neighbors = this.getNeighbors(current.gridX, current.gridY);\n\n      for (const neighbor of neighbors) {\n        const key = `${neighbor.gridX},${neighbor.gridY}`;\n\n        if (neighbor.color === targetColor && !visited.has(key)) {\n          visited.add(key);\n          queue.push(neighbor);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Получить соседей тайла (вверх, вниз, влево, вправо)\n   */\n  private getNeighbors(x: number, y: number): Tile[] {\n    const neighbors: Tile[] = [];\n    const directions = [\n      [0, 1],\n      [0, -1],\n      [-1, 0],\n      [1, 0],\n    ];\n\n    for (const [dx, dy] of directions) {\n      const neighbor = this.getTile(x + dx, y + dy);\n      if (neighbor) {\n        neighbors.push(neighbor);\n      }\n    }\n\n    return neighbors;\n  }\n\n  /**\n   * Проверка наличия доступных ходов\n   * @returns true если есть хотя бы одна группа из 2+ тайлов\n   */\n  public hasAvailableMoves(): boolean {\n    for (let x = 0; x < this.cols; x++) {\n      for (let y = 0; y < this.rows; y++) {\n        const tile = this.getTile(x, y);\n\n        if (!tile) {\n          continue;\n        }\n\n        const group = this.findConnectedGroup(x, y);\n\n        if (group.length >= 2) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Создать супер-тайл на указанной позиции\n   */\n  createSuperTile(\n    x: number,\n    y: number,\n    superType: import(\"./Tile\").SuperTileType,\n    color: TileColor,\n  ): Tile {\n    const superTile = new Tile(color, x, y, this.tileIdCounter++, superType);\n    this.setTile(x, y, superTile);\n    return superTile;\n  }\n\n  /**\n   * Получить все тайлы в строке\n   */\n  getTilesInRow(row: number): Tile[] {\n    const tiles: Tile[] = [];\n    for (let x = 0; x < this.cols; x++) {\n      const tile = this.getTile(x, row);\n      if (tile) {\n        tiles.push(tile);\n      }\n    }\n    return tiles;\n  }\n\n  /**\n   * Получить все тайлы в столбце\n   */\n  getTilesInColumn(col: number): Tile[] {\n    const tiles: Tile[] = [];\n    for (let y = 0; y < this.rows; y++) {\n      const tile = this.getTile(col, y);\n      if (tile) {\n        tiles.push(tile);\n      }\n    }\n    return tiles;\n  }\n\n  /**\n   * Получить тайлы в радиусе от точки\n   */\n  getTilesInRadius(centerX: number, centerY: number, radius: number): Tile[] {\n    const tiles: Tile[] = [];\n\n    for (let x = 0; x < this.cols; x++) {\n      for (let y = 0; y < this.rows; y++) {\n        const distance = Math.sqrt(\n          Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2),\n        );\n\n        if (distance <= radius) {\n          const tile = this.getTile(x, y);\n          if (tile) {\n            tiles.push(tile);\n          }\n        }\n      }\n    }\n\n    return tiles;\n  }\n\n  /**\n   * Получить все тайлы на доске\n   */\n  getAllTiles(): Tile[] {\n    const tiles: Tile[] = [];\n    for (let x = 0; x < this.cols; x++) {\n      for (let y = 0; y < this.rows; y++) {\n        const tile = this.getTile(x, y);\n        if (tile) {\n          tiles.push(tile);\n        }\n      }\n    }\n    return tiles;\n  }\n\n  /**\n   * Перемешать доску (алгоритм Fisher-Yates)\n   */\n  shuffle(): void {\n    const allTiles: Tile[] = [];\n    for (let x = 0; x < this.cols; x++) {\n      for (let y = 0; y < this.rows; y++) {\n        const tile = this.getTile(x, y);\n        if (tile) {\n          allTiles.push(tile);\n        }\n      }\n    }\n\n    for (let i = allTiles.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [allTiles[i], allTiles[j]] = [allTiles[j], allTiles[i]];\n    }\n\n    let index = 0;\n    for (let x = 0; x < this.cols; x++) {\n      for (let y = 0; y < this.rows; y++) {\n        this.setTile(x, y, allTiles[index++]);\n      }\n    }\n  }\n\n  /**\n   * Удаляет тайлы из сетки\n   */\n  removeTiles(tiles: Tile[]): void {\n    for (const tile of tiles) {\n      this.setTile(tile.gridX, tile.gridY, null);\n    }\n  }\n\n  /**\n   * Применяет гравитацию: тайлы падают вниз, пустоты заполняются новыми сверху\n   * @returns количество сдвинутых/созданных тайлов\n   */\n  applyGravity(): number {\n    let changesCount = 0;\n\n    for (let x = 0; x < this.cols; x++) {\n      const column: Tile[] = [];\n\n      for (let y = 0; y < this.rows; y++) {\n        const tile = this.grid[x][y];\n        if (tile) {\n          column.push(tile);\n        }\n      }\n\n      for (let y = 0; y < this.rows; y++) {\n        this.grid[x][y] = null;\n      }\n\n      let columnIndex = 0;\n      for (let y = 0; y < this.rows; y++) {\n        if (columnIndex < column.length) {\n          this.setTile(x, y, column[columnIndex]);\n          columnIndex++;\n          changesCount++;\n        } else {\n          this.setTile(x, y, this.createRandomTile(x, y));\n          changesCount++;\n        }\n      }\n    }\n\n    return changesCount;\n  }\n}\n"]}